// Class: openfl._internal.symbols.ShapeSymbol

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = require("./../../../hxClasses_stub").default;
var $import = require("./../../../import_stub").default;
var $extend = require("./../../../extend_stub").default;
function openfl__$internal_symbols_SWFSymbol() {return require("./../../../openfl/_internal/symbols/SWFSymbol");}
function openfl_display_Shape() {return require("./../../../openfl/display/Shape");}
function Type() {return require("./../../../Type");}
function openfl_display_BitmapData() {return require("./../../../openfl/display/BitmapData");}

// Constructor

var ShapeSymbol = function() {
	(openfl__$internal_symbols_SWFSymbol().default).call(this);
}

// Meta

ShapeSymbol.__name__ = ["openfl","_internal","symbols","ShapeSymbol"];
ShapeSymbol.__super__ = (openfl__$internal_symbols_SWFSymbol().default);
ShapeSymbol.prototype = $extend((openfl__$internal_symbols_SWFSymbol().default).prototype, {
	__createObject: function(swf) {
		var shape = new (openfl_display_Shape().default)();
		var graphics = shape.get_graphics();
		if(this.rendered != null) {
			graphics.copyFrom(this.rendered.get_graphics());
			return shape;
		}
		var _g = 0;
		var _g1 = this.commands;
		while(_g < _g1.length) {
			var command = _g1[_g];
			++_g;
			switch((Type().default).enumIndex(command)) {
			case 0:
				var smooth = command[5];
				var repeat = command[4];
				var matrix = command[3];
				var bitmapID = command[2];
				var bitmapSymbol = swf.symbols.get(bitmapID);
				var bitmap = swf.library.getImage(bitmapSymbol.path);
				if(bitmap != null) {
					graphics.beginBitmapFill((openfl_display_BitmapData().default).fromImage(bitmap),matrix,repeat,smooth);
				}
				break;
			case 1:
				var alpha = command[3];
				var color = command[2];
				graphics.beginFill(color,alpha);
				break;
			case 2:
				var focalPointRatio = command[9];
				var interpolationMethod = command[8];
				var spreadMethod = command[7];
				var matrix1 = command[6];
				var ratios = command[5];
				var alphas = command[4];
				var colors = command[3];
				var fillType = command[2];
				graphics.beginGradientFill(fillType,colors,alphas,ratios,matrix1,spreadMethod,interpolationMethod,focalPointRatio);
				break;
			case 3:
				var anchorY = command[5];
				var anchorX = command[4];
				var controlY = command[3];
				var controlX = command[2];
				graphics.curveTo(controlX,controlY,anchorX,anchorY);
				break;
			case 4:
				graphics.endFill();
				break;
			case 5:
				var miterLimit = command[9];
				var joints = command[8];
				var caps = command[7];
				var scaleMode = command[6];
				var pixelHinting = command[5];
				var alpha1 = command[4];
				var color1 = command[3];
				var thickness = command[2];
				if(thickness != null) {
					graphics.lineStyle(thickness,color1,alpha1,pixelHinting,scaleMode,caps,joints,miterLimit);
				} else {
					graphics.lineStyle();
				}
				break;
			case 6:
				var y = command[3];
				var x = command[2];
				graphics.lineTo(x,y);
				break;
			case 7:
				var y1 = command[3];
				var x1 = command[2];
				graphics.moveTo(x1,y1);
				break;
			}
		}
		this.commands = null;
		this.rendered = new (openfl_display_Shape().default)();
		this.rendered.get_graphics().copyFrom(shape.get_graphics());
		return shape;
	}
});
ShapeSymbol.prototype.__class__ = $hxClasses["openfl._internal.symbols.ShapeSymbol"] = ShapeSymbol;

// Init



// Statics




// Export

exports.default = ShapeSymbol;