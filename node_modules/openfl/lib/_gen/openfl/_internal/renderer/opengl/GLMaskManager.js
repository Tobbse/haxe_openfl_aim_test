// Class: openfl._internal.renderer.opengl.GLMaskManager

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = require("./../../../../hxClasses_stub").default;
var $import = require("./../../../../import_stub").default;
var $extend = require("./../../../../extend_stub").default;
function openfl__$internal_renderer_AbstractMaskManager() {return require("./../../../../openfl/_internal/renderer/AbstractMaskManager");}
function openfl_geom_Rectangle() {return require("./../../../../openfl/geom/Rectangle");}
function openfl__$internal_renderer_opengl_GLMaskShader() {return require("./../../../../openfl/_internal/renderer/opengl/GLMaskShader");}

// Constructor

var GLMaskManager = function(renderSession) {
	(openfl__$internal_renderer_AbstractMaskManager().default).call(this,renderSession);
	this.gl = renderSession.gl;
	this.clipRects = [];
	this.maskObjects = [];
	this.numClipRects = 0;
	this.stencilReference = 0;
	this.tempRect = new (openfl_geom_Rectangle().default)();
}

// Meta

GLMaskManager.__name__ = ["openfl","_internal","renderer","opengl","GLMaskManager"];
GLMaskManager.__super__ = (openfl__$internal_renderer_AbstractMaskManager().default);
GLMaskManager.prototype = $extend((openfl__$internal_renderer_AbstractMaskManager().default).prototype, {
	pushMask: function(mask) {
		if(this.stencilReference == 0) {
			this.gl.enable(this.gl.STENCIL_TEST);
			this.gl.stencilMask(255);
			this.gl.clear(this.gl.STENCIL_BUFFER_BIT);
		}
		this.gl.stencilOp(this.gl.KEEP,this.gl.KEEP,this.gl.INCR);
		this.gl.stencilFunc(this.gl.EQUAL,this.stencilReference,255);
		this.gl.colorMask(false,false,false,false);
		mask.__renderGLMask(this.renderSession);
		this.maskObjects.push(mask);
		this.stencilReference++;
		this.gl.stencilOp(this.gl.KEEP,this.gl.KEEP,this.gl.KEEP);
		this.gl.stencilFunc(this.gl.EQUAL,this.stencilReference,255);
		this.gl.colorMask(true,true,true,true);
	},
	pushObject: function(object,handleScrollRect) {
		if(handleScrollRect == null) {
			handleScrollRect = true;
		}
		if(handleScrollRect && object.__scrollRect != null) {
			this.pushRect(object.__scrollRect,object.__renderTransform);
		}
		if(object.__mask != null) {
			this.pushMask(object.__mask);
		}
	},
	pushRect: function(rect,transform) {
		if(this.numClipRects == this.clipRects.length) {
			this.clipRects[this.numClipRects] = new (openfl_geom_Rectangle().default)();
		}
		var clipRect = this.clipRects[this.numClipRects];
		rect.__transform(clipRect,transform);
		if(this.numClipRects > 0) {
			var parentClipRect = this.clipRects[this.numClipRects - 1];
			clipRect.__contract(parentClipRect.x,parentClipRect.y,parentClipRect.width,parentClipRect.height);
		}
		if(clipRect.height < 0) {
			clipRect.height = 0;
		}
		if(clipRect.width < 0) {
			clipRect.width = 0;
		}
		this.scissorRect(clipRect);
		this.numClipRects++;
	},
	popMask: function() {
		if(this.stencilReference == 0) {
			return;
		}
		if(this.stencilReference > 1) {
			this.gl.stencilOp(this.gl.KEEP,this.gl.KEEP,this.gl.DECR);
			this.gl.stencilFunc(this.gl.EQUAL,this.stencilReference,255);
			this.gl.colorMask(false,false,false,false);
			var mask = this.maskObjects.pop();
			mask.__renderGLMask(this.renderSession);
			this.stencilReference--;
			this.gl.stencilOp(this.gl.KEEP,this.gl.KEEP,this.gl.KEEP);
			this.gl.stencilFunc(this.gl.EQUAL,this.stencilReference,255);
			this.gl.colorMask(true,true,true,true);
		} else {
			this.stencilReference = 0;
			this.gl.disable(this.gl.STENCIL_TEST);
		}
	},
	popObject: function(object,handleScrollRect) {
		if(handleScrollRect == null) {
			handleScrollRect = true;
		}
		if(object.__mask != null) {
			this.popMask();
		}
		if(handleScrollRect && object.__scrollRect != null) {
			this.popRect();
		}
	},
	popRect: function() {
		if(this.numClipRects > 0) {
			this.numClipRects--;
			if(this.numClipRects > 0) {
				this.scissorRect(this.clipRects[this.numClipRects - 1]);
			} else {
				this.scissorRect();
			}
		}
	},
	scissorRect: function(rect) {
		if(rect != null) {
			var renderer = this.renderSession.renderer;
			this.gl.enable(this.gl.SCISSOR_TEST);
			var clipRect = this.tempRect;
			rect.__transform(clipRect,renderer.displayMatrix);
			var x = Math.floor(clipRect.x);
			var y = Math.floor(renderer.height - clipRect.y - clipRect.height);
			var width = Math.ceil(clipRect.width);
			var height = Math.ceil(clipRect.height);
			if(width < 0) {
				width = 0;
			}
			if(height < 0) {
				height = 0;
			}
			this.gl.scissor(x,y,width,height);
		} else {
			this.gl.disable(this.gl.SCISSOR_TEST);
		}
	}
});
GLMaskManager.prototype.__class__ = $hxClasses["openfl._internal.renderer.opengl.GLMaskManager"] = GLMaskManager;

// Init



// Statics


GLMaskManager.maskShader = new (openfl__$internal_renderer_opengl_GLMaskShader().default)()

// Export

exports.default = GLMaskManager;