// Class: openfl._internal.renderer.opengl.GLTilemap

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = require("./../../../../hxClasses_stub").default;
var $import = require("./../../../../import_stub").default;
function haxe_ds_IntMap() {return require("./../../../../haxe/ds/IntMap");}
function openfl_geom_Rectangle() {return require("./../../../../openfl/geom/Rectangle");}
function lime_utils__$DataPointer_DataPointer_$Impl_$() {return require("./../../../../lime/utils/_DataPointer/DataPointer_Impl_");}
function openfl__$internal_renderer_opengl_GLMaskManager() {return require("./../../../../openfl/_internal/renderer/opengl/GLMaskManager");}

// Constructor

var GLTilemap = function(){}

// Meta

GLTilemap.__name__ = ["openfl","_internal","renderer","opengl","GLTilemap"];
GLTilemap.prototype = {
	
};
GLTilemap.prototype.__class__ = $hxClasses["openfl._internal.renderer.opengl.GLTilemap"] = GLTilemap;

// Init



// Statics

GLTilemap.render = function(tilemap,renderSession) {
	if(!tilemap.__renderable || tilemap.__worldAlpha <= 0) {
		return;
	}
	tilemap.__updateTileArray();
	if(tilemap.__tileArray == null || tilemap.__tileArray.get_length() == 0) {
		return;
	}
	var renderer = renderSession.renderer;
	var gl = renderSession.gl;
	renderSession.blendModeManager.setBlendMode(tilemap.__worldBlendMode);
	renderSession.maskManager.pushObject(tilemap);
	renderSession.filterManager.pushObject(tilemap);
	var shader = renderSession.shaderManager.initShader(tilemap.shader);
	var uMatrix = renderer.getMatrix(tilemap.__renderTransform);
	var smoothing = renderSession.allowSmoothing && tilemap.smoothing;
	var useColorTransform = true;
	var rect = (openfl_geom_Rectangle().default).__pool.get();
	rect.setTo(0,0,tilemap.__width,tilemap.__height);
	renderSession.maskManager.pushRect(rect,tilemap.__renderTransform);
	var tileArray = tilemap.__tileArray;
	var defaultShader = shader;
	var defaultTileset = tilemap.__tileset;
	tileArray.__updateGLBuffer(gl,defaultTileset,tilemap.__worldAlpha,tilemap.__worldColorTransform);
	gl.vertexAttribPointer(shader.get_data().aPosition.index,2,gl.FLOAT,false,100,(lime_utils__$DataPointer_DataPointer_$Impl_$().default).fromInt(0));
	gl.vertexAttribPointer(shader.get_data().aTexCoord.index,2,gl.FLOAT,false,100,(lime_utils__$DataPointer_DataPointer_$Impl_$().default).fromInt(8));
	gl.vertexAttribPointer(shader.get_data().aAlpha.index,1,gl.FLOAT,false,100,(lime_utils__$DataPointer_DataPointer_$Impl_$().default).fromInt(16));
	gl.vertexAttribPointer(shader.get_data().aColorMultipliers0.index,4,gl.FLOAT,false,100,(lime_utils__$DataPointer_DataPointer_$Impl_$().default).fromInt(20));
	gl.vertexAttribPointer(shader.get_data().aColorMultipliers1.index,4,gl.FLOAT,false,100,(lime_utils__$DataPointer_DataPointer_$Impl_$().default).fromInt(36));
	gl.vertexAttribPointer(shader.get_data().aColorMultipliers2.index,4,gl.FLOAT,false,100,(lime_utils__$DataPointer_DataPointer_$Impl_$().default).fromInt(52));
	gl.vertexAttribPointer(shader.get_data().aColorMultipliers3.index,4,gl.FLOAT,false,100,(lime_utils__$DataPointer_DataPointer_$Impl_$().default).fromInt(68));
	gl.vertexAttribPointer(shader.get_data().aColorOffsets.index,4,gl.FLOAT,false,100,(lime_utils__$DataPointer_DataPointer_$Impl_$().default).fromInt(84));
	var cacheShader = null;
	var cacheBitmapData = null;
	var lastIndex = 0;
	var skipped = tileArray.__bufferSkipped;
	var drawCount = tileArray.__length;
	tileArray.position = 0;
	var shader1 = null;
	var tileset;
	var flush = false;
	var _g1 = 0;
	var _g = drawCount + 1;
	while(_g1 < _g) {
		var i = _g1++;
		if(skipped.get(i)) {
			continue;
		}
		tileArray.position = i < drawCount ? i : drawCount - 1;
		shader1 = tileArray.get_shader();
		if(shader1 == null) {
			shader1 = defaultShader;
		}
		if(shader1 != cacheShader && cacheShader != null) {
			flush = true;
		}
		tileset = tileArray.get_tileset();
		if(tileset == null) {
			tileset = defaultTileset;
		}
		if(tileset == null) {
			continue;
		}
		if(tileset.__bitmapData != cacheBitmapData && cacheBitmapData != null) {
			flush = true;
		}
		if(flush) {
			cacheShader.get_data().uImage0.input = cacheBitmapData;
			renderSession.shaderManager.updateShader(cacheShader);
			gl.drawArrays(gl.TRIANGLES,lastIndex * 6,(i - lastIndex) * 6);
			flush = false;
			lastIndex = i;
		}
		if(shader1 != cacheShader) {
			renderSession.shaderManager.setShader(shader1);
			shader1.get_data().uMatrix.value = uMatrix;
			shader1.get_data().uImage0.smoothing = smoothing;
			if(shader1.get_data().uColorTransform.value == null) {
				shader1.get_data().uColorTransform.value = [];
			}
			shader1.get_data().uColorTransform.value[0] = useColorTransform;
			cacheShader = shader1;
		}
		cacheBitmapData = tileset.__bitmapData;
		if(i == drawCount && tileset.__bitmapData != null) {
			shader1.get_data().uImage0.input = tileset.__bitmapData;
			renderSession.shaderManager.updateShader(shader1);
			gl.drawArrays(gl.TRIANGLES,lastIndex * 6,(i - lastIndex) * 6);
		}
	}
	renderSession.filterManager.popObject(tilemap);
	renderSession.maskManager.popRect();
	renderSession.maskManager.popObject(tilemap);
	(openfl_geom_Rectangle().default).__pool.release(rect);
}
GLTilemap.renderMask = function(tilemap,renderSession) {
	tilemap.__updateTileArray();
	if(tilemap.__tileArray == null || tilemap.__tileArray.get_length() == 0) {
		return;
	}
	var renderer = renderSession.renderer;
	var gl = renderSession.gl;
	var shader = (openfl__$internal_renderer_opengl_GLMaskManager().default).maskShader;
	var uMatrix = renderer.getMatrix(tilemap.__renderTransform);
	var smoothing = renderSession.allowSmoothing && tilemap.smoothing;
	var tileArray = tilemap.__tileArray;
	var defaultTileset = tilemap.__tileset;
	tileArray.__updateGLBuffer(gl,defaultTileset,tilemap.__worldAlpha,tilemap.__worldColorTransform);
	gl.vertexAttribPointer(shader.get_data().aPosition.index,2,gl.FLOAT,false,100,(lime_utils__$DataPointer_DataPointer_$Impl_$().default).fromInt(0));
	gl.vertexAttribPointer(shader.get_data().aTexCoord.index,2,gl.FLOAT,false,100,(lime_utils__$DataPointer_DataPointer_$Impl_$().default).fromInt(8));
	var cacheBitmapData = null;
	var lastIndex = 0;
	var skipped = tileArray.__bufferSkipped;
	var drawCount = tileArray.__length;
	tileArray.position = 0;
	var tileset;
	var flush = false;
	var _g1 = 0;
	var _g = drawCount + 1;
	while(_g1 < _g) {
		var i = _g1++;
		if(skipped.get(i)) {
			continue;
		}
		tileArray.position = i < drawCount ? i : drawCount - 1;
		tileset = tileArray.get_tileset();
		if(tileset == null) {
			tileset = defaultTileset;
		}
		if(tileset == null) {
			continue;
		}
		if(tileset.__bitmapData != cacheBitmapData && cacheBitmapData != null) {
			flush = true;
		}
		if(flush) {
			shader.get_data().uImage0.input = cacheBitmapData;
			renderSession.shaderManager.updateShader(shader);
			gl.drawArrays(gl.TRIANGLES,lastIndex * 6,(i - lastIndex) * 6);
			flush = false;
			lastIndex = i;
		}
		cacheBitmapData = tileset.__bitmapData;
		if(i == drawCount && tileset.__bitmapData != null) {
			shader.get_data().uImage0.input = tileset.__bitmapData;
			renderSession.shaderManager.updateShader(shader);
			gl.drawArrays(gl.TRIANGLES,lastIndex * 6,(i - lastIndex) * 6);
		}
	}
}
GLTilemap.__skippedTiles = new (haxe_ds_IntMap().default)()

// Export

exports.default = GLTilemap;