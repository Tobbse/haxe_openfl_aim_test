// Class: openfl._internal.stage3D.opengl.GLVertexBuffer3D

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = require("./../../../../hxClasses_stub").default;
var $import = require("./../../../../import_stub").default;
function openfl__$internal_stage3D_GLUtils() {return require("./../../../../openfl/_internal/stage3D/GLUtils");}
function openfl_utils__$ByteArray_ByteArray_$Impl_$() {return require("./../../../../openfl/utils/_ByteArray/ByteArray_Impl_");}
function lime_graphics_opengl__$WebGLContext_WebGLContext_$Impl_$() {return require("./../../../../lime/graphics/opengl/_WebGLContext/WebGLContext_Impl_");}

// Constructor

var GLVertexBuffer3D = function(){}

// Meta

GLVertexBuffer3D.__name__ = ["openfl","_internal","stage3D","opengl","GLVertexBuffer3D"];
GLVertexBuffer3D.prototype = {
	
};
GLVertexBuffer3D.prototype.__class__ = $hxClasses["openfl._internal.stage3D.opengl.GLVertexBuffer3D"] = GLVertexBuffer3D;

// Init



// Statics

GLVertexBuffer3D.create = function(vertexBuffer,renderSession,bufferUsage) {
	var gl = renderSession.gl;
	vertexBuffer.__id = gl.createBuffer();
	(openfl__$internal_stage3D_GLUtils().default).CheckGLError();
	vertexBuffer.__stride = vertexBuffer.__vertexSize * 4;
	vertexBuffer.__usage = bufferUsage == "dynamicDraw" ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
}
GLVertexBuffer3D.dispose = function(vertexBuffer,renderSession) {
	var gl = renderSession.gl;
	gl.deleteBuffer(vertexBuffer.__id);
}
GLVertexBuffer3D.uploadFromByteArray = function(vertexBuffer,renderSession,data,byteArrayOffset,startVertex,numVertices) {
	var offset = byteArrayOffset + startVertex * vertexBuffer.__stride;
	var length = numVertices * vertexBuffer.__vertexSize;
	var buffer = (openfl_utils__$ByteArray_ByteArray_$Impl_$().default).toArrayBuffer(data);
	var this1;
	if(buffer != null) {
		if(length == null) {
			this1 = new Float32Array(buffer,offset);
		} else {
			this1 = new Float32Array(buffer,offset,length);
		}
	} else {
		this1 = null;
	}
	GLVertexBuffer3D.uploadFromTypedArray(vertexBuffer,renderSession,this1);
}
GLVertexBuffer3D.uploadFromTypedArray = function(vertexBuffer,renderSession,data) {
	if(data == null) {
		return;
	}
	var gl = renderSession.gl;
	gl.bindBuffer(gl.ARRAY_BUFFER,vertexBuffer.__id);
	(openfl__$internal_stage3D_GLUtils().default).CheckGLError();
	(lime_graphics_opengl__$WebGLContext_WebGLContext_$Impl_$().default).bufferData(gl,gl.ARRAY_BUFFER,data,vertexBuffer.__usage);
	(openfl__$internal_stage3D_GLUtils().default).CheckGLError();
}
GLVertexBuffer3D.uploadFromVector = function(vertexBuffer,renderSession,data,startVertex,numVertices) {
	if(data == null) {
		return;
	}
	var gl = renderSession.gl;
	var start = startVertex * vertexBuffer.__vertexSize;
	var count = numVertices * vertexBuffer.__vertexSize;
	var length = start + count;
	var existingFloat32Array = vertexBuffer.__tempFloat32Array;
	if(vertexBuffer.__tempFloat32Array == null || vertexBuffer.__tempFloat32Array.length < count) {
		var this1;
		if(count != null) {
			this1 = new Float32Array(count);
		} else {
			this1 = null;
		}
		vertexBuffer.__tempFloat32Array = this1;
		if(existingFloat32Array != null) {
			vertexBuffer.__tempFloat32Array.set(existingFloat32Array);
		}
	}
	var _g1 = start;
	var _g = length;
	while(_g1 < _g) {
		var i = _g1++;
		vertexBuffer.__tempFloat32Array[i - start] = data.get(i);
	}
	GLVertexBuffer3D.uploadFromTypedArray(vertexBuffer,renderSession,vertexBuffer.__tempFloat32Array);
}


// Export

exports.default = GLVertexBuffer3D;