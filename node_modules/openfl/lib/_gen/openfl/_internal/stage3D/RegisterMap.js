// Class: openfl._internal.stage3D.RegisterMap

var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this

$global.Object.defineProperty(exports, "__esModule", {value: true});

var __map_reserved = {};

// Imports

var $hxClasses = require("./../../../hxClasses_stub").default;
var $import = require("./../../../import_stub").default;
function js__$Boot_HaxeError() {return require("./../../../js/_Boot/HaxeError");}
function openfl_errors_IllegalOperationError() {return require("./../../../openfl/errors/IllegalOperationError");}
function openfl__$internal_stage3D__$AGALConverter_RegisterMapEntry() {return require("./../../../openfl/_internal/stage3D/_AGALConverter/RegisterMapEntry");}
function openfl__$internal_stage3D_AGALConverter() {return require("./../../../openfl/_internal/stage3D/AGALConverter");}
function openfl__$internal_stage3D__$AGALConverter_RegisterUsage() {return require("./../../../openfl/_internal/stage3D/_AGALConverter/RegisterUsage");}
function haxe_ds_ObjectMap() {return require("./../../../haxe/ds/ObjectMap");}
function js_Boot() {return require("./../../../js/Boot");}
function StringBuf() {return require("./../../../StringBuf");}
function Type() {return require("./../../../Type");}
function haxe_Log() {return require("./../../../haxe/Log");}

// Constructor

var RegisterMap = function() {
	this.mEntries = [];
}

// Meta

RegisterMap.__name__ = ["openfl","_internal","stage3D","RegisterMap"];
RegisterMap.prototype = {
	add: function(type,name,number,usage) {
		var _g = 0;
		var _g1 = this.mEntries;
		while(_g < _g1.length) {
			var entry = _g1[_g];
			++_g;
			if(entry.type == type && entry.name == name && entry.number == number) {
				if(entry.usage != usage) {
					throw new (js__$Boot_HaxeError().default)(new (openfl_errors_IllegalOperationError().default)("Cannot use register in multiple ways yet (mat4/vec4)"));
				}
				return;
			}
		}
		var entry1 = new (openfl__$internal_stage3D__$AGALConverter_RegisterMapEntry().default)();
		entry1.type = type;
		entry1.name = name;
		entry1.number = number;
		entry1.usage = usage;
		this.mEntries.push(entry1);
	},
	addDR: function(dr,usage) {
		this.add(dr.type,dr.toGLSL(false),dr.n,usage);
	},
	addSaR: function(sr,usage) {
		this.add(sr.type,sr.toGLSL(),sr.n,usage);
	},
	addSR: function(sr,usage,offset) {
		if(offset == null) {
			offset = 0;
		}
		if(sr.d != 0) {
			this.add(sr.itype,(openfl__$internal_stage3D_AGALConverter().default).prefixFromType(sr.itype,sr.programType) + sr.n,sr.n,(openfl__$internal_stage3D__$AGALConverter_RegisterUsage().default).VECTOR_4);
			this.add(sr.type,(openfl__$internal_stage3D_AGALConverter().default).prefixFromType(sr.type,sr.programType) + sr.o,sr.o,(openfl__$internal_stage3D__$AGALConverter_RegisterUsage().default).VECTOR_4_ARRAY);
			return;
		}
		this.add(sr.type,sr.toGLSL(false,offset),sr.n + offset,usage);
	},
	getRegisterUsage: function(sr) {
		if(sr.d != 0) {
			return (openfl__$internal_stage3D__$AGALConverter_RegisterUsage().default).VECTOR_4_ARRAY;
		}
		return this.getUsage(sr.type,sr.toGLSL(false),sr.n);
	},
	getUsage: function(type,name,number) {
		var _g = 0;
		var _g1 = this.mEntries;
		while(_g < _g1.length) {
			var entry = _g1[_g];
			++_g;
			if(entry.type == type && entry.name == name && entry.number == number) {
				return entry.usage;
			}
		}
		return (openfl__$internal_stage3D__$AGALConverter_RegisterUsage().default).UNUSED;
	},
	toGLSL: function(tempRegistersOnly) {
		this.mEntries.sort(function(a,b) {
			return a.number - b.number;
		});
		var arrayCount = new (haxe_ds_ObjectMap().default)();
		var entry;
		var _g1 = 0;
		var _g = this.mEntries.length;
		while(_g1 < _g) {
			var i = _g1++;
			entry = this.mEntries[i];
			if(entry.usage == (openfl__$internal_stage3D__$AGALConverter_RegisterUsage().default).VECTOR_4_ARRAY) {
				if(i < this.mEntries.length - 1) {
					var v = this.mEntries[i + 1].number - entry.number;
					arrayCount.set(entry,v);
				} else {
					arrayCount.set(entry,128);
				}
			}
		}
		this.mEntries.sort(function(a1,b1) {
			return (js_Boot().default).__cast(a1.type , $hxClasses["Int"]) - (js_Boot().default).__cast(b1.type , $hxClasses["Int"]);
		});
		var sb = new (StringBuf().default)();
		var _g11 = 0;
		var _g2 = this.mEntries.length;
		while(_g11 < _g2) {
			var i1 = _g11++;
			entry = this.mEntries[i1];
			if(tempRegistersOnly && entry.type != 2 || !tempRegistersOnly && entry.type == 2) {
				continue;
			}
			if(entry.type == 3) {
				continue;
			}
			var _g21 = entry.type;
			switch(_g21) {
			case 0:
				sb.add("attribute ");
				break;
			case 1:
				sb.add("uniform ");
				break;
			case 2:
				sb.add("\t");
				break;
			case 3:
				break;
			case 4:
				sb.add("varying ");
				break;
			case 5:
				sb.add("uniform ");
				break;
			default:
				throw new (js__$Boot_HaxeError().default)(new (openfl_errors_IllegalOperationError().default)());
			}
			var _g3 = entry.usage;
			switch((Type().default).enumIndex(_g3)) {
			case 0:
				(haxe_Log().default).trace("Missing switch patten: RegisterUsage.UNUSED",{ fileName : "AGALConverter.hx", lineNumber : 839, className : "openfl._internal.stage3D.RegisterMap", methodName : "toGLSL"});
				break;
			case 1:
				sb.add("vec4 ");
				break;
			case 2:
				sb.add("mat4 ");
				break;
			case 3:
				sb.add("sampler2D ");
				break;
			case 4:
				break;
			case 5:
				sb.add("samplerCube ");
				break;
			case 6:
				break;
			case 7:
				sb.add("vec4 ");
				break;
			}
			if(entry.usage == (openfl__$internal_stage3D__$AGALConverter_RegisterUsage().default).SAMPLER_2D_ALPHA) {
				sb.add("sampler2D ");
				sb.add(entry.name);
				sb.add(";\n");
				sb.add("uniform ");
				sb.add("sampler2D ");
				sb.add(entry.name + "_alpha");
				sb.add(";\n");
				sb.add("uniform ");
				sb.add("bool ");
				sb.add(entry.name + "_alphaEnabled");
				sb.add(";\n");
			} else if(entry.usage == (openfl__$internal_stage3D__$AGALConverter_RegisterUsage().default).SAMPLER_CUBE_ALPHA) {
				sb.add("samplerCube ");
				sb.add(entry.name);
				sb.add(";\n");
				sb.add("uniform ");
				sb.add("samplerCube ");
				sb.add(entry.name + "_alpha");
				sb.add(";\n");
				sb.add("uniform ");
				sb.add("bool ");
				sb.add(entry.name + "_alphaEnabled");
				sb.add(";\n");
			} else if(entry.usage == (openfl__$internal_stage3D__$AGALConverter_RegisterUsage().default).VECTOR_4_ARRAY) {
				sb.add(entry.name + "[" + arrayCount.get(entry) + "]");
				sb.add(";\n");
			} else {
				sb.add(entry.name);
				sb.add(";\n");
			}
		}
		return sb.toString();
	}
};
RegisterMap.prototype.__class__ = $hxClasses["openfl._internal.stage3D.RegisterMap"] = RegisterMap;

// Init



// Statics




// Export

exports.default = RegisterMap;